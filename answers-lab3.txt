1.What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)

因为对不同的异常和中断，处理方式是不同的，有的会返回程序继续运行，有的不会，所以用一个handler会很难实现

2.Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint's code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint's int $14 instruction to invoke the kernel's page fault handler (which is interrupt vector 14)?


观察user/softint.c和grade-lab3。大致可以看出在softint.c中
asm volatile("int $14");    // page fault
想要引发一个page fault (interrupt vector 14)
但是实际上正确结果却会引发一个general protection fault (trap 13)
理由是 int 14这个指令是不能在user mode下运行的，用户态权限为3，而这个指令权限为0,所以会先引发trap 13， general protection fault。 想要强行运行的话，要在SETGATE时权限设置成3

3.
The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?


理由与上一题相同。
使用
SETGATE(idt[T_BRKPT], 1, GD_KT, t_brkpt, 3);
使可以正确触发break point exception
使用
SETGATE(idt[T_BRKPT], 1, GD_KT, t_brkpt, 0);
则会导致general protection fault

4.
What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?

// - dpl: Descriptor Privilege Level -
//	  the privilege level required for software to invoke
//	  this interrupt/trap gate explicitly using an int instruction.
#define SETGATE(gate, istrap, sel, off, dpl)	

gd_dpl控制优先级，其值越小，优先级越高，优先级低的不能直接访问优先级高的代码。





Exercise 9
 在backtrace时会引发page fault.
 输入backtrace输出如下：
Stack backtrace:
ebp efbfff10  eip f01008fb  args 00000001 efbfff28 f01a1000 00000000 f017e920
kern/monitor.c:152: monitor+275
ebp efbfff80  eip f0103cb4  args f01a1000 efbfffbc 00000000 00000000 00000000
kern/trap.c:196: trap+189
ebp efbfffb0  eip f0103e0b  args efbfffbc 00000000 00000000 eebfdfd0 efbfffdc
kern/trapentry.S:112: <unknown>+0
ebp eebfdfd0  eip 0080007f  args 00000000 00000000 00000000 00000000 00000000
lib/libmain.c:27: libmain+67
Incoming TRAP frame at 0xefbffe7c
kernel panic at kern/trap.c:264


回想Lab1内容，我们是先读取ebp的值，然后将该值作为地址，输出stack上的内容，stack的结构如下
	arg5
	arg4
	arg3
	arg2
	arg1
	返回地址，被Push的eip
	上一个ebp.<---------------当前ebp的指向

那么我们看到最后一条打印的ebp为0xeebfdfd0,也就是说，我们下一条理应打印出
0xeebfdfd0中的内容作为ebp，然后以新的ebp为地址打印出这个地址之上的6个值。

在用gdb看0xeebfbfd0中的内容是什么之前，我们先猜测一下，我们期待打出的这条信息应该是什么，我们能看到，应该是在某处调用了libmain.c中libmain()，我们会打印这个信息。而这个某处就是在lib/entry.S中，
能看到：
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
	jne args_exist

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
	pushl $0

args_exist:
	call libmain
1:	jmp 1b
 

在调用之前，我们Push了两个0.
而在Push之前我们可以看到我们保证了esp的值等于USTACKTOP，也就是说，我们在USTACKTOP的位置push了两个值，问题原因就在这里，我们是要打印5个arg，而在打印完两个arg之后，第3个arg的位置相当于位于USTACKTOP之上，超出了允许的范围，因此会有page fault,
解决方案，我们改成只打印2个arg即可。。。
拿gdb查看之后，也确实如此。
